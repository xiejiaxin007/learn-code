/*
 * @description: 
 * @author: xiejiaxin
 * @e-mail: xiejx@glodon.com
 * @Date: 2024-03-19 14:40:35
 * @desc: 只是为了能够记忆一下
 */


// ? 1、浏览器请求方式
//    get（获取资源）、post（提交资源）、delete（删除某个资源）、options（预请求）、put（跟post比较像，但是这个是指定了服务器的位置）、head、trace、connect

// ? 2、从输入url——>页面显示的过程？
//  1、url需要对应的dns解析（大致版本）
//    !我们这儿查看缓存主要是针对于文件资源而非接口数据，看浏览器的时候注意筛选一下哦
//    dns解析需要分为两种情况：命中缓存（在过期时间内/未在过期时间内）、未命中缓存：https://github.com/amandakelake/blog/issues/41
//      如果是命中缓存了，则需要判断是否是在有效期内，如果在有效期内的话，则可以直接进行读取，如果已经过期了，则需要重新进行请求来判断是从服务端读取还是从缓存中读取，之后进行再次缓存（是否缓存可能还需要看文件的设置情况）
//      *强缓存（启用了缓存）
//      !不需要对服务器发起请求
//      *请求返回的是200(memory cache)/200(disk cache)
//      判断是否在有效期内：expires（http1.0）和cache-control（http1.1）——这两种方式属于强缓存
//      --expires：http1.0时候出的，主要是设置一个过期时间，这个时间是格林威治时间，但是有一个很大的问题，用户可以通过修改电脑的本地时间来扰乱过期时间
//      --cache-control：由于expires的缺陷，在http1.1的时候又新增了这个属性，优先级高于expires
//        ----max-age：设置的过期时间，是一个秒单位的数字（最常见的使用方式）
//        ----public：表示任何资源都进行缓存（客户端和代理服务器都可以）
//        ----private：可以换成，但是不包括代理服务器，也就是存入私有缓存
//        ----no-cache：很多人认为是不缓存，实际是需要缓存，只不过max-age=0
//        ----no-store：绝对不缓存
//      *协商缓存（启用了缓存，但是缓存过期了，需要请求服务器，检查一下失效后的文件是否更新过，如果更新过的话则重新拿数据，如果没有更新则仍然可以从缓存中获取）
//      !前提一定是开启了强缓存，才有协商缓存的判断
//      !需要跟服务器做一次请求，如果缓存过期了但是服务器判断资源没有改变，也就是可以继续使用缓存，则直接读取缓存，服务器返回也是空的，如果资源已经变了，则需要读取服务器返回的内容
//      *请求返回的是304
//      --last-modified：上次修改的时间；会根据If-Modified-Since来进行判断，看文件是否更新过，但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag
//      --etag：优先级更高；跟修改时间没有关系，算是一个指纹，ETag可以保证每一个资源是唯一的，If-None-Match的header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来
//      *缓存中的文件不可用，需求直接获取服务器返回的资源
//      *请求返回的是200
//      --缓存没有命中
//      --命中缓存但是文件已经修改，需要下载最新的资源
//      --直接设置了不缓存的文件

//  2、dns查找:获取ip地址
//    浏览器缓存-->本机缓存-->hosts对应查找-->路由缓存-->ISP DNS缓存-->DNS递归查询（可能存在负载均衡导致每次IP不⼀样）

//  3、http握手和挥手机制
//    如果判断需要进行服务器请求，则我们需要对url进行dns解析，找到url对应的ip地址，进行服务器的请求
//    开始请求的时候，进行tcp的链接
//      *三次握手(实质上是先进行http的连接,此时还没有真正进行数据请求)
//      --浏览器对服务器：询问服务器是否可以进行请求
//      --服务器对浏览器:告诉浏览器,我这边可以跟你进行通信
//      --浏览器对服务器:好的,那我们就算建立链接了,那你可以给我资源了
//      !此时真正请求开始,会走前面说的缓存策略,返回对应的200/3XX/4XX/5XX等情况
//      *四次挥手
//      --浏览器对服务器:好了我拿完数据了,请求关闭连接
//      --服务器对浏览器:好的,你等我这边检查一下是否完成了数据发送
//      --服务器对浏览器:好的,我发送完了,你那边也可以关闭了
//      --浏览器对服务器:ok,再会

//  4、拿到信息后可以进行判断,是否需要缓存,然后是否需要解压,做对应的解压操作

//  5、拿到文件后的自上而下的解析
//    自上而下开始解析,遇到html或者css就直接进行解析,遇到js会被阻塞,遇到文件内容则会开启下载
//    *dom树
//      1. Tokenizing：根据HTML规范将字符流解析为标记
//      2. Lexing：词法分析将标记转换为对象并定义属性和规则
//      3. DOM construction：根据HTML标记关系将对象组成DOM树
//    *css树
//      1. Tokenizing：字符流转换为标记流
//      2. Node：根据标记创建节点
//      3. CSSOM：节点创建CSSOM树
//    *构建渲染树
//      根据cssom和dom树进行合并绘制,可以确定好可见元素的在页面中的位置什么的,也就是将内容样式都计算清楚
//      1. 从DOM树的根节点遍历所有可⻅节点，不可⻅节点包括：1） script , meta 这样本身不可⻅的标签。2)被css隐藏的节点，如
//      2. 对每⼀个可⻅节点，找到恰当的CSSOM规则并应⽤
//      3. 发布可视节点的内容和计算样式
//    *js加载
//      1. 浏览器创建document对象,并且开始解析html,将解析到的html加入到文档中,此时浏览器状态为document.readyState状态为loading
//      2. 浏览器遇到非defer和async的js,也就是非异步的js,则直接进行script的执行(同步的js代码),此时渲染停止,可以进行document.write的操作,这也是为什么js执行的时候会暂停页面渲染了
//      4. 浏览器遇到async的js,会进行js的下载,会在下载完成后尽快执行,它不会阻止浏览器的解析
//      5. 文档解析完成,document.readyState变为interactive
//      6. defer的js进行执行,它会按照在⽂档出现的顺序执⾏,它不会阻止浏览器的解析
//      7. 此时会触发DocumentContentLoaded事件
//      8. js相关文档都解析完成,但是此时可能会有图片等资源还在下载中,readyState也变成了complete,等这些资源都下载完成后,就会触发loaded事件了
//      ! defer表示等同步的代码渲染完成后再进行解析,并且defer是在DocumentContentLoaded之前执行
//      ! async则表示独立的js,我不影响你们,你们也别影响我,我只要下载完成了我就自己执行了,所以async可能在DocumentContentLoaed之前执行也可能之后

//  6、显示页面