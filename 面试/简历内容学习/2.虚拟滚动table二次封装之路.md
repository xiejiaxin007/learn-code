# 基于element-ui进行封装

### element-ui新增组件
element-ui有专门的makefile文件，在linux环境下，可以直接使用make，所以我们只需要在element-ui的源码根目录，直接运行代码：
componentName就是我们要创建的新组建
```
make new [componentName]
```
```
make new vir-table
```

## 编写虚拟滚动table组件
### 复制table组件
为了不影响原本table组件的使用，我们直接复制一份table组件代码，将组件name值修改为ELVirTable即可

### 新增虚拟滚动代码
这里虚拟滚动实现的原理，是通过将`table-body`的容器设置成一个所有data都渲染出来的高度，也就是需要计算出高度，这样可以让滚动条在正常的位置
而这个高度，我们采用的是`paddingTop`和`paddingBottom`的设置
```html
<table-body
:context="context"
:store="store"
:stripe="stripe"
:row-class-name="rowClassName"
:row-style="rowStyle"
:highlight="highlightCurrentRow"
:style="{
    width: bodyWidth,
    paddingTop: paddingTop + 'px',
    paddingBottom: paddingBottom + 'px'
}">
</table-body>
```
虚拟滚动另外一点，就是data数据只渲染一屏，所以我们需要监听data，截取出当前出入给table的data数组
```js
watch:{
data: {
    immediate: true,
    handler(value) {
        // kangx：初始不要把所有数据传入表格
        if (this.scrollDom) {
        let scrollList = value.slice(this.startIndex, this.startIndex + this.showNum);
        // 数据改变时，滑动条在顶部，滑动条长度位置重新计算
        if (scrollList.length > 0) {
            this.paddingTop = this.scrollIndex * this.itemHeight;
            let allHeight = value.length * this.itemHeight;
            this.paddingBottom = allHeight - this.itemHeight * this.showNum - this.paddingTop;
        } else {
            this.paddingTop = 0;
            this.paddingBottom = 0;
        }
        this.store.commit('setData', scrollList);
        } else {
        this.store.commit('setData', value);
        }
        // 所有数据传入，虚拟DOM多选时有用
        this.store.commit('setAllData', value);
    }
    },
    startIndex: {
        immediate: true,
        handler() {
          if (this.scrollDom) {
            let scrollList = this.data.slice(this.startIndex, this.startIndex + this.showNum);
            this.store.commit('setData', scrollList);
            this.$emit('getCurIndex', this.startIndex);
            this.$emit('update:scrollIndex', this.startIndex);
          }
        }
      },
      // kangx：定位滚动
      scrollIndex: {
        handler(val) {
          this.bodyWrapper.scrollTo(0, val * this.itemHeight);
        }
      },
}
```
同时，我们需要实时记录渲染的数据`startIndex`和`endIndex`，这样才能准确找到当前这一屏的数据，这个值我们可以在滚动监听的时候进行计算，同时也要试试更新`paddingTop`和`paddingBottom`的值
```js
syncPostion: throttle(50, function() {
        const { scrollLeft, scrollTop, offsetWidth, scrollWidth } = this.bodyWrapper;
        const { headerWrapper, footerWrapper, fixedBodyWrapper, rightFixedBodyWrapper } = this.$refs;
        if (headerWrapper) headerWrapper.scrollLeft = scrollLeft;
        if (footerWrapper) footerWrapper.scrollLeft = scrollLeft;
        if (fixedBodyWrapper) fixedBodyWrapper.scrollTop = scrollTop;
        if (rightFixedBodyWrapper) rightFixedBodyWrapper.scrollTop = scrollTop;
        const maxScrollLeftPosition = scrollWidth - offsetWidth - 1;
        if (scrollLeft >= maxScrollLeftPosition) {
          this.scrollPosition = 'right';
        } else if (scrollLeft === 0) {
          this.scrollPosition = 'left';
        } else {
          this.scrollPosition = 'middle';
        }
        // ! 这个地方可以进行数据截取
        this.startIndex = Math.floor(scrollTop / this.itemHeight)
        this.endIndex = this.startIndex + this.showNum
        this.paddingTop = scrollTop
        // 判断边界
        if (this.endIndex >= this.data.length) {
          this.paddingTop = (this.data.length - this.showNum) * this.itemHeight
          this.paddingBottom = 0
          return
        }
        let allHeight = this.data.length * this.itemHeight
        this.paddingBottom = allHeight - (this.showNum * this.itemHeight) - scrollTop
      }),

      bindEvents() {
        this.bodyWrapper.addEventListener('scroll', this.syncPostion, { passive: true });
        if (this.fit) {
          addResizeListener(this.$el, this.resizeListener);
        }
      },
```
还有个比较关键的地方，需要给当前的table弄出来滚动条，因为`el-table`出现滚动条的方式就是设置好max-height，所以我们需要在mounted完成后，重新给layout赋值一遍
```js
this.$nextTick(() => {
        const { headerHeight = 0, footerHeight = 0} = this.layout;
          // 横向滑动条高度
          let gutterHeight = this.layout.scrollX ? this.layout.gutterWidth : 0;
          if (this.showNum === 0) {
            this.layout.setMaxHeight(60 + (this.showHeader ? headerHeight : 0) + footerHeight + gutterHeight);
          } else {
            this.layout.setMaxHeight(this.itemHeight * this.showNum + (this.showHeader ? headerHeight : 0) + footerHeight + gutterHeight);
          }
      })
```
